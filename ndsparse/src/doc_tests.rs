//! Instances for documentation tests or tests.

use crate::{coo::CooArray, csl::CslArray};
#[cfg(feature = "alloc")]
use crate::{coo::CooVec, csl::CslVec};
use cl_traits::ArrayWrapper;

type CooArray5 = CooArray<[usize; 5], [(ArrayWrapper<[usize; 5]>, i32); 7]>;

/// As odd as it may seem, this illustration is just a guide to get a grasp of
/// a 5D structure.
///
/// ```rust
/// //          ___ ___ ___            ___ ___ ___            ___ ___ ___
/// //        /   /   /   /\         / 3 /   /   /\         /   /   /   /\
/// //       /___/___/___/ /\       /_3_/___/___/ /\       /___/___/___/ /\
/// //      /   /   /   /\/ /\     /   /   /   /\/ /\     /   / 4 /   /\/ /\
/// //     /___/___/___/ /\/ /    /___/___/___/ /\/ /    /___/_4_/___/ /\/ /
/// //    /   /   /   /\/ /\/    /   /   /   /\/ /\/    /   /   /   /\/ /\/
/// //   /___/___/___/ /\/ /    /___/___/___/ /\/ /    /___/___/___/ /\/ /
/// //  /   /   /   /\/1/\/    /   /   /   /\/ /\/    /   /   /   /\/ /\/
/// // /___/___/___/ /\/ /    /___/___/___/ /\/ /    /___/___/___/ /\/ /
/// // \___\___\___\/ /\/     \___\___\___\/ /\/     \___\___\___\/ /\/
/// //  \___\___\___\/ /       \___\_2_\___\/ /       \___\___\___\/ /
/// //   \___\___\___\/         \___\___\___\/         \___\___\___\/
/// //
/// //          ___ ___ ___            ___ ___ ___            ___ ___ ___
/// //        /   /   /   /\         /   /   /   /\         /   /   / 6 /\
/// //       /___/___/___/ /\       /___/___/___/ /\       /___/___/_6_/6/\
/// //      /   /   /   /\/ /\     /   /   /   /\/ /\     /   /   /   /\/ /\
/// //     /___/___/___/ /\/ /    /___/___/___/ /\/ /    /___/___/___/ /\/7/
/// //    /   /   /   /\/ /\/    /   /   /   /\/ /\/    /   /   /   /\/ /\/
/// //   /___/___/___/ /\/ /    /___/___/___/ /\/ /    /___/___/___/ /\/ /
/// //  /   /   /   /\/ /\/    /   /   /   /\/ /\/    /   /   /   /\/ /\/
/// // /___/___/___/ /\/ /    /___/___/___/ /\/ /    /___/___/___/ /\/ /
/// // \___\___\___\/ /\/     \___\___\___\/ /\/     \___\___\___\/ /\/
/// //  \___\___\___\/ /       \___\___\___\/ /       \___\___\___\/ /
/// //   \___\___\___\/         \___\_5_\___\/         \___\___\___\/
/// use ndsparse::coo::CooArray;
/// let _ = CooArray::new(
///   [2, 3, 4, 3, 3],
///   [
///     ([0, 0, 1, 1, 2].into(), 1),
///     ([0, 1, 0, 1, 1].into(), 2),
///     ([0, 1, 3, 0, 0].into(), 3),
///     ([0, 2, 2, 0, 1].into(), 4),
///     ([1, 1, 0, 2, 1].into(), 5),
///     ([1, 2, 3, 0, 2].into(), 6),
///     ([1, 2, 3, 2, 2].into(), 7),
///   ],
/// );
/// ```
pub fn coo_array_5() -> CooArray5 {
  CooArray {
    dims: [2, 3, 4, 3, 3].into(),
    data: [
      ([0, 0, 1, 1, 2].into(), 1),
      ([0, 1, 0, 1, 1].into(), 2),
      ([0, 1, 3, 0, 0].into(), 3),
      ([0, 2, 2, 0, 1].into(), 4),
      ([1, 1, 0, 2, 1].into(), 5),
      ([1, 2, 3, 0, 2].into(), 6),
      ([1, 2, 3, 2, 2].into(), 7),
    ]
    .into(),
  }
}

/// [`Vec`](alloc::vec::Vec) version of [`coo_array_5`].
#[cfg(feature = "alloc")]
pub fn coo_vec_5() -> CooVec<[usize; 5], i32> {
  let coo = coo_array_5();
  CooVec { dims: coo.dims, data: coo.data.to_vec() }
}

/// Two cuboids illustrating a [2, 3, 4, 5] 4D in a [w, y, z, x] order, i.e., each "line"
/// or 1D representation is a left to right row and each "matrix" or 2D representation
/// is filled in a top-down manner.
///
/// ```rust
/// // w: left to right
/// // y: top to bottom
/// // z: front to back
/// // x: left to right
/// //
/// //          ___ ___ ___ ___ ___            ___ ___ ___ ___ ___
/// //        /   /   /   / 4 / 5 /\         /   /   /   /   /   /\
/// //       /___/___/___/_4_/_5_/5/\       /___/___/___/___/___/ /\
/// //      /   /   /   /   /   /\/ /\     /   /   / 9 /   /   /\/ /\
/// //     /___/___/___/___/___/ /\/ /    /___/___/_9_/___/___/ /\/ /
/// //    /   / 3 /   /   /   /\/ /\/    /   /   /   /   /   /\/ /\/
/// //   /___/_3_/___/___/___/ /\/ /    /___/_ _/___/___/___/ /\/ /
/// //  / 1 /   /   / 2 /   /\/ /\/    /   /   /   /   /   /\/ /\/
/// // /_1_/___/___/_2_/___/ /\/8/    /___/___/___/___/___/ /\/ /
/// // \_1_\___\___\_2_\___\/ /\/     \___\___\___\___\___\/ /\/
/// //  \___\___\_6_\___\___\/ /       \___\___\___\___\___\/ /
/// //   \___\___\_7_\___\___\/         \___\___\___\___\___\/
/// use ndsparse::csl::CslArray;
/// let _ = CslArray::new(
///   [2, 3, 4, 5],
///   [1, 2, 3, 4, 5, 6, 7, 8, 9],
///   [0, 3, 1, 3, 4, 2, 2, 4, 2],
///   [0, 2, 3, 3, 5, 6, 6, 6, 6, 7, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9],
/// );
/// ```
pub fn csl_array_4() -> CslArray<[usize; 4], [i32; 9], [usize; 9], [usize; 25]> {
  CslArray {
    data: [1, 2, 3, 4, 5, 6, 7, 8, 9].into(),
    dims: [2, 3, 4, 5].into(),
    indcs: [0, 3, 1, 3, 4, 2, 2, 4, 2].into(),
    offs: [0, 2, 3, 3, 5, 6, 6, 6, 6, 7, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9].into(),
  }
}

/// [`Vec`](alloc::vec::Vec) version of [`csl_array_4`].
#[cfg(feature = "alloc")]
pub fn csl_vec_4() -> CslVec<[usize; 4], i32> {
  let csl = csl_array_4();
  CslVec {
    data: csl.data.to_vec(),
    dims: csl.dims,
    indcs: csl.indcs.to_vec(),
    offs: csl.offs.to_vec(),
  }
}
